import os
from typing import cast

from Crypto.PublicKey.ECC import generate, EccKey, import_key, construct, EccPoint
from Crypto.Signature import eddsa

from seev_cryptography.lib.ecc.named_curve_ecc_point import NamedCurveEccPoint
from seev_cryptography.lib.ecc.type_mapping.crypto_curves import CryptoCurve, EddsaCurve

"""
The Crypto.PublicKey.ECC.generate method generates a private key with a public component.
We can treat this as a key pair, although the object itself returned by the generate() function should be treated as private, of course.
We can access the public key using the .public_key() method, which removes the private attributes and returns just the public component.
We should export keys using a passphrase and protection algorithm, which must be the same for all exports/imports so that we can properly serialise/de-serialise.
Importing keys with only a public component does not expect the passphrase or protection kwargs, so they need different methods than key pairs.
I suspect there is no redundant information in the exported (private) key pair; it only contains the private component, and the public component is recalculated upon import.
"""


class KeyGenerationUtils:
	@staticmethod
	def generate_ecc_key_pair(curve: CryptoCurve) -> EccKey:
		"""
		Generate a public/private key pair on the given curve
		"""
		return generate(curve=curve)

	@staticmethod
	def generate_eddsa_key_pair(curve: EddsaCurve) -> EccKey:
		"""
		Generate a key pair to be used for signing/verifying messages with the eddsa protocol
		"""
		return generate(curve=curve)


class EccKeySerialisationUtils:
	@staticmethod
	def export_public_key_as_string(key: EccKey, compress: bool = True):
		"""
		Export a public EccKey in text PEM format
		Args:
			key: The key to export
			compress: Whether to compress the public key, keeping only the x coordinate (32 byte saving on NIST P-256)
		Returns:
			text PEM representation of the key
		"""
		if key.has_private():
			raise ValueError("That is not a public key! Cannot export a key which has a private component without encryption.")
		return key.export_key(format='PEM', compress=compress)

	@staticmethod
	def export_public_private_key_pair_as_binary(key: EccKey) -> bytes:
		"""
		Export an EccKey with private and public components to binary DER format with a passphrase
		Compression has no effect on private keys
		Args:
			key: The key to export
		Returns:
			binary DER representation of the key, protected with a passphrase
		"""
		return key.export_key(format='DER', passphrase=os.environ.get('ELECTION_KEY_PASSPHRASE'), protection='PBKDF2WithHMAC-SHA1AndAES128-CBC')

	@staticmethod
	def export_public_key_as_binary(key: EccKey, compress: bool = True) -> bytes:
		"""
		Export a public EccKey in binary DER format
		Args:
			key: The key to export
			compress: Whether to compress the public key, keeping only the x coordinate (32 byte saving on NIST P-256)
		Returns:
			binary DER representation of the key
		"""
		if key.has_private():
			raise ValueError("That is not a public key! Cannot export a key which has a private component without encryption.")
		return key.export_key(format='DER', compress=compress)

	@staticmethod
	def import_public_private_key_pair_from_binary(exported_key: bytes) -> EccKey:
		"""
		Import a binary public/private key pair generated by :py:meth:`key_utils.EccKeySerialisationUtils.export_public_private_key_pair_as_binary`
		"""
		return import_key(exported_key, passphrase=os.environ.get('ELECTION_KEY_PASSPHRASE'))

	@staticmethod
	def import_public_key_from_binary(exported_key: bytes) -> EccKey:
		"""Import a public EccKey generated using :py:meth:`key_utils.EccKeySerialisationUtils.export_public_key_as_binary`"""
		return import_key(exported_key)

	@staticmethod
	def import_public_key_from_string(exported_key: str) -> EccKey:
		"""Import a public EccKey generated using :py:meth:`key_utils.EccKeySerialisationUtils.export_public_key_as_string`"""
		return import_key(exported_key)


class EccPointSerialisationUtils:
	@staticmethod
	def export_ecc_point_as_string_public_key(point: EccPoint, curve: CryptoCurve, compress: bool = True) -> str:
		"""
		Export an EccPoint as a public EccKey in text PEM format
		Args:
			point: The point to export
			curve: the curve the point is on
			compress: Whether to compress the public key repr of the point, keeping only the x coordinate (32 byte saving on NIST P-256)
		Returns:
			text PEM representation of the key
		"""
		key_repr = construct(point_x=point.x, point_y=point.y, curve=curve)
		return EccKeySerialisationUtils.export_public_key_as_string(key_repr, compress=compress)

	@staticmethod
	def export_ecc_point_as_binary_public_key(point: EccPoint, curve: CryptoCurve, compress: bool = True) -> bytes:
		"""
		Export an EccPoint as a public EccKey in binary DER format
		Args:
			point: The point to export
			curve: the curve the point is on
			compress: Whether to compress the public key repr of the point, keeping only the x coordinate (32 byte saving on NIST P-256)
		Returns:
			binary DER representation of the key
		"""
		key_repr = construct(point_x=point.x, point_y=point.y, curve=curve)
		return EccKeySerialisationUtils.export_public_key_as_binary(key_repr, compress=compress)

	@staticmethod
	def import_ecc_point_from_binary_public_key(exported_point: bytes) -> EccPoint:
		"""Import an EccPoint which was exported using the :py:meth:`key_utils.EccKeySerialisationUtils.export_ecc_point_as_binary_public_key`"""
		key_repr: EccKey = EccKeySerialisationUtils.import_public_key_from_binary(exported_point)
		return key_repr.pointQ

	@staticmethod
	def import_named_curve_ecc_point_from_binary_public_key(exported_point: bytes) -> NamedCurveEccPoint:
		"""Import a NamedCurveEccPoint which was exported using the :py:meth:`key_utils.EccKeySerialisationUtils.export_ecc_point_as_binary_public_key`"""
		key_repr: EccKey = EccKeySerialisationUtils.import_public_key_from_binary(exported_point)
		# EccKey.curve is one of the strings specified in pycryptodome library and CryptoCurve type
		return NamedCurveEccPoint.from_ecc_point(key_repr.pointQ, cast(CryptoCurve, key_repr.curve))

	@staticmethod
	def import_named_curve_ecc_point_from_string_public_key(exported_point: str) -> NamedCurveEccPoint:
		"""Import a NamedCurveEccPoint which was exported using the :py:meth:`key_utils.EccKeySerialisationUtils.export_ecc_point_as_string_public_key`"""
		key_repr: EccKey = EccKeySerialisationUtils.import_public_key_from_string(exported_point)
		# EccKey.curve is one of the strings specified in pycryptodome library and CryptoCurve type
		return NamedCurveEccPoint.from_ecc_point(key_repr.pointQ, cast(CryptoCurve, key_repr.curve))


class EddsaSignatureUtils:
	@staticmethod
	def sign(message: bytes, private_key: EccKey) -> bytes:
		"""
		Sign a message using a private key created from an eddsa curve, i.e. created using :py:meth:`key_utils.KeyGenerationUtils.generate_eddsa_key_pair`
		Args:
			message: The message to sign
			private_key: The private key to sign with (the key must be on an EddsaCurve)
		Returns:
			the signed message
		"""
		sign_key: eddsa.EdDSASigScheme = eddsa.new(private_key, 'rfc8032')
		return sign_key.sign(message)

	@staticmethod
	def verify(message: bytes, signature: bytes, public_key: EccKey) -> None:
		"""
		Verify that a signature has been produced using the :py:meth:`key_utils.EddsaSignatureUtils.sign` method and the same public key
		Args:
			message: the message that was signed
			signature: the signature of the message
			public_key: public key to verify against
		Returns:
			None
		Raises:
			ValueError if the signature is not authentic
		"""
		sign_key: eddsa.EdDSASigScheme = eddsa.new(public_key, 'rfc8032')
		sign_key.verify(message, signature)
